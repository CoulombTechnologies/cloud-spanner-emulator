//
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#include "backend/query/information_schema_catalog.h"

#include "backend/schema/printer/print_ddl.h"

namespace google {
namespace spanner {
namespace emulator {
namespace backend {

namespace {

using zetasql::types::BoolType;
using zetasql::types::BytesType;
using zetasql::types::Int64Type;
using zetasql::types::StringType;
using zetasql::values::Bool;
using zetasql::values::Int64;
using zetasql::values::NullBytes;
using zetasql::values::NullInt64;
using zetasql::values::NullString;
using zetasql::values::String;

constexpr char kInformationSchema[] = "INFORMATION_SCHEMA";

//
// This metadata table was generated by running the following query against
// cloud spanner.
//
//   SELECT TABLE_NAME, COLUMN_NAME, IS_NULLABLE, SPANNER_TYPE
//   FROM INFORMATION_SCHEMA.COLUMNS
//   WHERE TABLE_SCHEMA='INFORMATION_SCHEMA'
//   ORDER BY TABLE_NAME ASC, COLUMN_NAME ASC;
//
struct ColumnsMetaEntry {
  const char* table_name;
  const char* column_name;
  const char* is_nullable;
  const char* spanner_type;
};
const std::vector<ColumnsMetaEntry>* ColumnsMetadata() {
  static const auto* data = new std::vector<ColumnsMetaEntry>{
      {"CHECK_CONSTRAINTS", "CHECK_CLAUSE", "NO", "STRING(MAX)"},
      {"CHECK_CONSTRAINTS", "CONSTRAINT_CATALOG", "NO", "STRING(MAX)"},
      {"CHECK_CONSTRAINTS", "CONSTRAINT_NAME", "NO", "STRING(MAX)"},
      {"CHECK_CONSTRAINTS", "CONSTRAINT_SCHEMA", "NO", "STRING(MAX)"},
      {"CHECK_CONSTRAINTS", "SPANNER_STATE", "NO", "STRING(MAX)"},
      {"COLUMNS", "COLUMN_DEFAULT", "YES", "BYTES(MAX)"},
      {"COLUMNS", "COLUMN_NAME", "NO", "STRING(MAX)"},
      {"COLUMNS", "DATA_TYPE", "YES", "STRING(MAX)"},
      {"COLUMNS", "GENERATION_EXPRESSION", "NO", "STRING(MAX)"},
      {"COLUMNS", "IS_GENERATED", "NO", "STRING(MAX)"},
      {"COLUMNS", "IS_NULLABLE", "YES", "STRING(MAX)"},
      {"COLUMNS", "IS_STORED", "YES", "STRING(MAX)"},
      {"COLUMNS", "ORDINAL_POSITION", "NO", "INT64"},
      {"COLUMNS", "SPANNER_STATE", "YES", "STRING(MAX)"},
      {"COLUMNS", "SPANNER_TYPE", "YES", "STRING(MAX)"},
      {"COLUMNS", "TABLE_CATALOG", "NO", "STRING(MAX)"},
      {"COLUMNS", "TABLE_NAME", "NO", "STRING(MAX)"},
      {"COLUMNS", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
      {"COLUMN_OPTIONS", "COLUMN_NAME", "NO", "STRING(MAX)"},
      {"COLUMN_OPTIONS", "OPTION_NAME", "NO", "STRING(MAX)"},
      {"COLUMN_OPTIONS", "OPTION_TYPE", "NO", "STRING(MAX)"},
      {"COLUMN_OPTIONS", "OPTION_VALUE", "NO", "STRING(MAX)"},
      {"COLUMN_OPTIONS", "TABLE_CATALOG", "NO", "STRING(MAX)"},
      {"COLUMN_OPTIONS", "TABLE_NAME", "NO", "STRING(MAX)"},
      {"COLUMN_OPTIONS", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
      {"CONSTRAINT_COLUMN_USAGE", "COLUMN_NAME", "NO", "STRING(MAX)"},
      {"CONSTRAINT_COLUMN_USAGE", "CONSTRAINT_CATALOG", "NO", "STRING(MAX)"},
      {"CONSTRAINT_COLUMN_USAGE", "CONSTRAINT_NAME", "NO", "STRING(MAX)"},
      {"CONSTRAINT_COLUMN_USAGE", "CONSTRAINT_SCHEMA", "NO", "STRING(MAX)"},
      {"CONSTRAINT_COLUMN_USAGE", "TABLE_CATALOG", "NO", "STRING(MAX)"},
      {"CONSTRAINT_COLUMN_USAGE", "TABLE_NAME", "NO", "STRING(MAX)"},
      {"CONSTRAINT_COLUMN_USAGE", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
      {"CONSTRAINT_TABLE_USAGE", "CONSTRAINT_CATALOG", "NO", "STRING(MAX)"},
      {"CONSTRAINT_TABLE_USAGE", "CONSTRAINT_NAME", "NO", "STRING(MAX)"},
      {"CONSTRAINT_TABLE_USAGE", "CONSTRAINT_SCHEMA", "NO", "STRING(MAX)"},
      {"CONSTRAINT_TABLE_USAGE", "TABLE_CATALOG", "NO", "STRING(MAX)"},
      {"CONSTRAINT_TABLE_USAGE", "TABLE_NAME", "NO", "STRING(MAX)"},
      {"CONSTRAINT_TABLE_USAGE", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
      {"DATABASE_OPTIONS", "CATALOG_NAME", "NO", "STRING(MAX)"},
      {"DATABASE_OPTIONS", "OPTION_NAME", "NO", "STRING(MAX)"},
      {"DATABASE_OPTIONS", "OPTION_TYPE", "NO", "STRING(MAX)"},
      {"DATABASE_OPTIONS", "OPTION_VALUE", "NO", "STRING(MAX)"},
      {"DATABASE_OPTIONS", "SCHEMA_NAME", "NO", "STRING(MAX)"},
      {"INDEXES", "INDEX_NAME", "NO", "STRING(MAX)"},
      {"INDEXES", "INDEX_STATE", "NO", "STRING(100)"},
      {"INDEXES", "INDEX_TYPE", "NO", "STRING(MAX)"},
      {"INDEXES", "IS_NULL_FILTERED", "NO", "BOOL"},
      {"INDEXES", "IS_UNIQUE", "NO", "BOOL"},
      {"INDEXES", "PARENT_TABLE_NAME", "NO", "STRING(MAX)"},
      {"INDEXES", "SPANNER_IS_MANAGED", "NO", "BOOL"},
      {"INDEXES", "TABLE_CATALOG", "NO", "STRING(MAX)"},
      {"INDEXES", "TABLE_NAME", "NO", "STRING(MAX)"},
      {"INDEXES", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
      {"INDEX_COLUMNS", "COLUMN_NAME", "NO", "STRING(MAX)"},
      {"INDEX_COLUMNS", "COLUMN_ORDERING", "YES", "STRING(MAX)"},
      {"INDEX_COLUMNS", "INDEX_NAME", "NO", "STRING(MAX)"},
      {"INDEX_COLUMNS", "INDEX_TYPE", "NO", "STRING(MAX)"},
      {"INDEX_COLUMNS", "IS_NULLABLE", "YES", "STRING(MAX)"},
      {"INDEX_COLUMNS", "ORDINAL_POSITION", "YES", "INT64"},
      {"INDEX_COLUMNS", "SPANNER_TYPE", "YES", "STRING(MAX)"},
      {"INDEX_COLUMNS", "TABLE_CATALOG", "NO", "STRING(MAX)"},
      {"INDEX_COLUMNS", "TABLE_NAME", "NO", "STRING(MAX)"},
      {"INDEX_COLUMNS", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
      {"KEY_COLUMN_USAGE", "COLUMN_NAME", "NO", "STRING(MAX)"},
      {"KEY_COLUMN_USAGE", "CONSTRAINT_CATALOG", "NO", "STRING(MAX)"},
      {"KEY_COLUMN_USAGE", "CONSTRAINT_NAME", "NO", "STRING(MAX)"},
      {"KEY_COLUMN_USAGE", "CONSTRAINT_SCHEMA", "NO", "STRING(MAX)"},
      {"KEY_COLUMN_USAGE", "ORDINAL_POSITION", "NO", "INT64"},
      {"KEY_COLUMN_USAGE", "POSITION_IN_UNIQUE_CONSTRAINT", "YES", "INT64"},
      {"KEY_COLUMN_USAGE", "TABLE_CATALOG", "NO", "STRING(MAX)"},
      {"KEY_COLUMN_USAGE", "TABLE_NAME", "NO", "STRING(MAX)"},
      {"KEY_COLUMN_USAGE", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
      {"REFERENTIAL_CONSTRAINTS", "CONSTRAINT_CATALOG", "NO", "STRING(MAX)"},
      {"REFERENTIAL_CONSTRAINTS", "CONSTRAINT_NAME", "NO", "STRING(MAX)"},
      {"REFERENTIAL_CONSTRAINTS", "CONSTRAINT_SCHEMA", "NO", "STRING(MAX)"},
      {"REFERENTIAL_CONSTRAINTS", "DELETE_RULE", "NO", "STRING(MAX)"},
      {"REFERENTIAL_CONSTRAINTS", "MATCH_OPTION", "NO", "STRING(MAX)"},
      {"REFERENTIAL_CONSTRAINTS", "SPANNER_STATE", "NO", "STRING(MAX)"},
      {"REFERENTIAL_CONSTRAINTS", "UNIQUE_CONSTRAINT_CATALOG", "YES",
       "STRING(MAX)"},
      {"REFERENTIAL_CONSTRAINTS", "UNIQUE_CONSTRAINT_NAME", "YES",
       "STRING(MAX)"},
      {"REFERENTIAL_CONSTRAINTS", "UNIQUE_CONSTRAINT_SCHEMA", "YES",
       "STRING(MAX)"},
      {"REFERENTIAL_CONSTRAINTS", "UPDATE_RULE", "NO", "STRING(MAX)"},
      {"SCHEMATA", "CATALOG_NAME", "NO", "STRING(MAX)"},
      {"SCHEMATA", "EFFECTIVE_TIMESTAMP", "YES", "INT64"},
      {"SCHEMATA", "SCHEMA_NAME", "NO", "STRING(MAX)"},
      {"TABLES", "ON_DELETE_ACTION", "YES", "STRING(MAX)"},
      {"TABLES", "PARENT_TABLE_NAME", "YES", "STRING(MAX)"},
      {"TABLES", "SPANNER_STATE", "YES", "STRING(MAX)"},
      {"TABLES", "TABLE_CATALOG", "NO", "STRING(MAX)"},
      {"TABLES", "TABLE_NAME", "NO", "STRING(MAX)"},
      {"TABLES", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
      {"TABLE_CONSTRAINTS", "CONSTRAINT_CATALOG", "NO", "STRING(MAX)"},
      {"TABLE_CONSTRAINTS", "CONSTRAINT_NAME", "NO", "STRING(MAX)"},
      {"TABLE_CONSTRAINTS", "CONSTRAINT_SCHEMA", "NO", "STRING(MAX)"},
      {"TABLE_CONSTRAINTS", "CONSTRAINT_TYPE", "NO", "STRING(MAX)"},
      {"TABLE_CONSTRAINTS", "ENFORCED", "NO", "STRING(MAX)"},
      {"TABLE_CONSTRAINTS", "INITIALLY_DEFERRED", "NO", "STRING(MAX)"},
      {"TABLE_CONSTRAINTS", "IS_DEFERRABLE", "NO", "STRING(MAX)"},
      {"TABLE_CONSTRAINTS", "TABLE_CATALOG", "NO", "STRING(MAX)"},
      {"TABLE_CONSTRAINTS", "TABLE_NAME", "NO", "STRING(MAX)"},
      {"TABLE_CONSTRAINTS", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
  };
  return data;
}

//
// This metadata table was generated by running the following query against
// cloud spanner.
//
//   SELECT TABLE_NAME, COLUMN_NAME, IS_NULLABLE, COLUMN_ORDERING, SPANNER_TYPE
//   FROM INFORMATION_SCHEMA.INDEX_COLUMNS
//   WHERE TABLE_SCHEMA='INFORMATION_SCHEMA'
//   ORDER BY TABLE_NAME ASC, COLUMN_NAME ASC;
//
struct IndexColumnsMetaEntry {
  const char* table_name;
  const char* column_name;
  const char* is_nullable;
  const char* column_ordering;
  const char* spanner_type;
};
const std::vector<IndexColumnsMetaEntry>* IndexColumnsMetadata() {
  static const auto* data = new std::vector<IndexColumnsMetaEntry>{
      {"CHECK_CONSTRAINTS", "CONSTRAINT_CATALOG", "NO", "ASC", "STRING(MAX)"},
      {"CHECK_CONSTRAINTS", "CONSTRAINT_NAME", "NO", "ASC", "STRING(MAX)"},
      {"CHECK_CONSTRAINTS", "CONSTRAINT_SCHEMA", "NO", "ASC", "STRING(MAX)"},
      {"COLUMNS", "COLUMN_NAME", "NO", "ASC", "STRING(MAX)"},
      {"COLUMNS", "TABLE_CATALOG", "NO", "ASC", "STRING(MAX)"},
      {"COLUMNS", "TABLE_NAME", "NO", "ASC", "STRING(MAX)"},
      {"COLUMNS", "TABLE_SCHEMA", "NO", "ASC", "STRING(MAX)"},
      {"COLUMN_OPTIONS", "COLUMN_NAME", "NO", "ASC", "STRING(MAX)"},
      {"COLUMN_OPTIONS", "OPTION_NAME", "NO", "ASC", "STRING(MAX)"},
      {"COLUMN_OPTIONS", "TABLE_CATALOG", "NO", "ASC", "STRING(MAX)"},
      {"COLUMN_OPTIONS", "TABLE_NAME", "NO", "ASC", "STRING(MAX)"},
      {"COLUMN_OPTIONS", "TABLE_SCHEMA", "NO", "ASC", "STRING(MAX)"},
      {"CONSTRAINT_COLUMN_USAGE", "COLUMN_NAME", "NO", "ASC", "STRING(MAX)"},
      {"CONSTRAINT_COLUMN_USAGE", "CONSTRAINT_CATALOG", "NO", "ASC",
       "STRING(MAX)"},
      {"CONSTRAINT_COLUMN_USAGE", "CONSTRAINT_NAME", "NO", "ASC",
       "STRING(MAX)"},
      {"CONSTRAINT_COLUMN_USAGE", "CONSTRAINT_SCHEMA", "NO", "ASC",
       "STRING(MAX)"},
      {"CONSTRAINT_TABLE_USAGE", "CONSTRAINT_CATALOG", "NO", "ASC",
       "STRING(MAX)"},
      {"CONSTRAINT_TABLE_USAGE", "CONSTRAINT_NAME", "NO", "ASC", "STRING(MAX)"},
      {"CONSTRAINT_TABLE_USAGE", "CONSTRAINT_SCHEMA", "NO", "ASC",
       "STRING(MAX)"},
      {"CONSTRAINT_TABLE_USAGE", "TABLE_CATALOG", "NO", "ASC", "STRING(MAX)"},
      {"CONSTRAINT_TABLE_USAGE", "TABLE_NAME", "NO", "ASC", "STRING(MAX)"},
      {"CONSTRAINT_TABLE_USAGE", "TABLE_SCHEMA", "NO", "ASC", "STRING(MAX)"},
      {"DATABASE_OPTIONS", "CATALOG_NAME", "NO", "ASC", "STRING(MAX)"},
      {"DATABASE_OPTIONS", "OPTION_NAME", "NO", "ASC", "STRING(MAX)"},
      {"DATABASE_OPTIONS", "SCHEMA_NAME", "NO", "ASC", "STRING(MAX)"},
      {"INDEXES", "INDEX_NAME", "NO", "ASC", "STRING(MAX)"},
      {"INDEXES", "INDEX_TYPE", "NO", "ASC", "STRING(MAX)"},
      {"INDEXES", "TABLE_CATALOG", "NO", "ASC", "STRING(MAX)"},
      {"INDEXES", "TABLE_NAME", "NO", "ASC", "STRING(MAX)"},
      {"INDEXES", "TABLE_SCHEMA", "NO", "ASC", "STRING(MAX)"},
      {"INDEX_COLUMNS", "COLUMN_NAME", "NO", "ASC", "STRING(MAX)"},
      {"INDEX_COLUMNS", "INDEX_NAME", "NO", "ASC", "STRING(MAX)"},
      {"INDEX_COLUMNS", "INDEX_TYPE", "NO", "ASC", "STRING(MAX)"},
      {"INDEX_COLUMNS", "TABLE_CATALOG", "NO", "ASC", "STRING(MAX)"},
      {"INDEX_COLUMNS", "TABLE_NAME", "NO", "ASC", "STRING(MAX)"},
      {"INDEX_COLUMNS", "TABLE_SCHEMA", "NO", "ASC", "STRING(MAX)"},
      {"KEY_COLUMN_USAGE", "COLUMN_NAME", "NO", "ASC", "STRING(MAX)"},
      {"KEY_COLUMN_USAGE", "CONSTRAINT_CATALOG", "NO", "ASC", "STRING(MAX)"},
      {"KEY_COLUMN_USAGE", "CONSTRAINT_NAME", "NO", "ASC", "STRING(MAX)"},
      {"KEY_COLUMN_USAGE", "CONSTRAINT_SCHEMA", "NO", "ASC", "STRING(MAX)"},
      {"REFERENTIAL_CONSTRAINTS", "CONSTRAINT_CATALOG", "NO", "ASC",
       "STRING(MAX)"},
      {"REFERENTIAL_CONSTRAINTS", "CONSTRAINT_NAME", "NO", "ASC",
       "STRING(MAX)"},
      {"REFERENTIAL_CONSTRAINTS", "CONSTRAINT_SCHEMA", "NO", "ASC",
       "STRING(MAX)"},
      {"SCHEMATA", "CATALOG_NAME", "NO", "ASC", "STRING(MAX)"},
      {"SCHEMATA", "SCHEMA_NAME", "NO", "ASC", "STRING(MAX)"},
      {"TABLES", "TABLE_CATALOG", "NO", "ASC", "STRING(MAX)"},
      {"TABLES", "TABLE_NAME", "NO", "ASC", "STRING(MAX)"},
      {"TABLES", "TABLE_SCHEMA", "NO", "ASC", "STRING(MAX)"},
      {"TABLE_CONSTRAINTS", "CONSTRAINT_CATALOG", "NO", "ASC", "STRING(MAX)"},
      {"TABLE_CONSTRAINTS", "CONSTRAINT_NAME", "NO", "ASC", "STRING(MAX)"},
      {"TABLE_CONSTRAINTS", "CONSTRAINT_SCHEMA", "NO", "ASC", "STRING(MAX)"},
  };
  return data;
}

// Try to find a metadata entry from metadata_entries.
template <typename T>
typename std::vector<T>::const_iterator TryFindMetadata(
    const std::vector<T>* metadata_entries, const std::string& table_name,
    const std::string& column_name) {
  for (auto it = metadata_entries->cbegin(); it != metadata_entries->cend();
       ++it) {
    if (table_name == it->table_name && column_name == it->column_name)
      return it;
  }
  return metadata_entries->cend();
}

}  // namespace

InformationSchemaCatalog::InformationSchemaCatalog(const Schema* default_schema)
    : zetasql::SimpleCatalog(kName), default_schema_(default_schema) {
  AddSchemataTable();
  auto* tables = AddTablesTable();
  auto* columns = AddColumnsTable();
  auto* indexes = AddIndexesTable();
  auto* index_columns = AddIndexColumnsTable();
  AddColumnOptionsTable();

  // These tables are populated only after all tables have been added to the
  // catalog (including meta tables) because they add rows based on the tables
  // in the catalog.
  FillTablesTable(tables);
  FillColumnsTable(columns);
  FillIndexesTable(indexes);
  FillIndexColumnsTable(index_columns);
}

void InformationSchemaCatalog::AddSchemataTable() {
  // Setup table schema.
  auto schemata = new zetasql::SimpleTable(
      "SCHEMATA",
      {{"CATALOG_NAME", StringType()}, {"SCHEMA_NAME", StringType()}});

  // Add table rows.
  std::vector<std::vector<zetasql::Value>> rows;
  rows.push_back({String(""), String("")});
  rows.push_back({String(""), String("INFORMATION_SCHEMA")});

  // Add table to catalog.
  schemata->SetContents(rows);
  AddOwnedTable(schemata);
}

zetasql::SimpleTable* InformationSchemaCatalog::AddTablesTable() {
  // Setup table schema.
  auto tables =
      new zetasql::SimpleTable("TABLES", {{"TABLE_CATALOG", StringType()},
                                            {"TABLE_SCHEMA", StringType()},
                                            {"TABLE_NAME", StringType()},
                                            {"PARENT_TABLE_NAME", StringType()},
                                            {"ON_DELETE_ACTION", StringType()},
                                            {"SPANNER_STATE", StringType()}});
  // Add table to catalog so it is included in rows.
  AddOwnedTable(tables);
  return tables;
}

void InformationSchemaCatalog::FillTablesTable(zetasql::SimpleTable* tables) {
  // Add table rows.
  std::vector<std::vector<zetasql::Value>> rows;
  for (const Table* table : default_schema_->tables()) {
    rows.push_back({
        // table_catalog
        String(""),
        // table_schema
        String(""),
        // table_name
        String(table->Name()),
        // parent_table_name
        table->parent() ? String(table->parent()->Name()) : NullString(),
        // on_delete_action
        table->parent()
            ? String(OnDeleteActionToString(table->on_delete_action()))
            : NullString(),
        // spanner_state,
        String("COMMITTED"),
    });
  }

  for (const auto& table : this->tables()) {
    rows.push_back({
        // table_catalog
        String(""),
        // table_schema
        String(kInformationSchema),
        // table_name
        String(table->Name()),
        // parent_table_name
        NullString(),
        // on_delete_action
        NullString(),
        // spanner_state,
        NullString(),
    });
  }

  tables->SetContents(rows);
}

zetasql::SimpleTable* InformationSchemaCatalog::AddColumnsTable() {
  // Setup table schema.
  auto columns =
      new zetasql::SimpleTable("COLUMNS", {{"TABLE_CATALOG", StringType()},
                                             {"TABLE_SCHEMA", StringType()},
                                             {"TABLE_NAME", StringType()},
                                             {"COLUMN_NAME", StringType()},
                                             {"ORDINAL_POSITION", Int64Type()},
                                             {"COLUMN_DEFAULT", BytesType()},
                                             {"DATA_TYPE", StringType()},
                                             {"IS_NULLABLE", StringType()},
                                             {"SPANNER_TYPE", StringType()},
                                             {"SPANNER_STATE", StringType()}});
  AddOwnedTable(columns);
  return columns;
}

void InformationSchemaCatalog::FillColumnsTable(
    zetasql::SimpleTable* columns) {
  // Add table rows.
  std::vector<std::vector<zetasql::Value>> rows;
  for (const Table* table : default_schema_->tables()) {
    int pos = 1;
    for (const Column* column : table->columns()) {
      rows.push_back({
          // table_catalog
          String(""),
          // table_schema
          String(""),
          // table_name
          String(table->Name()),
          // column_name
          String(column->Name()),
          // ordinal_position
          Int64(pos++),
          // column_default,
          NullBytes(),
          // data_type,
          NullString(),
          // is_nullable
          String(column->is_nullable() ? "YES" : "NO"),
          // spanner_type
          String(ColumnTypeToString(column->GetType(),
                                    column->declared_max_length())),
          // spanner_state
          String("COMMITTED"),
      });
    }
  }

  // Add columns for the tables that live inside INFORMATION_SCHEMA.
  for (const auto& table : this->tables()) {
    int pos = 1;
    for (int i = 0; i < table->NumColumns(); ++i) {
      const zetasql::Column* column = table->GetColumn(i);
      auto m =
          TryFindMetadata(ColumnsMetadata(), table->Name(), column->Name());
      if (m == ColumnsMetadata()->end()) {
        LOG(DFATAL) << "Missing metadata entry for " << table->Name() << ", "
                    << column->Name();
        continue;
      }

      rows.push_back({
          // table_catalog
          String(""),
          // table_schema
          String(kInformationSchema),
          // table_name
          String(table->Name()),
          // column_name
          String(column->Name()),
          // ordinal_position
          Int64(pos++),
          // column_default,
          NullBytes(),
          // data_type,
          NullString(),
          // is_nullable
          String(m->is_nullable),
          // spanner_type
          String(m->spanner_type),
          // spanner_state
          NullString(),
      });
    }
  }

  // Add table to catalog.
  columns->SetContents(rows);
}

zetasql::SimpleTable* InformationSchemaCatalog::AddIndexesTable() {
  // Setup table schema.
  auto indexes = new zetasql::SimpleTable(
      "INDEXES", {
                     {"TABLE_CATALOG", StringType()},
                     {"TABLE_SCHEMA", StringType()},
                     {"TABLE_NAME", StringType()},
                     {"INDEX_NAME", StringType()},
                     {"INDEX_TYPE", StringType()},
                     {"PARENT_TABLE_NAME", StringType()},
                     {"IS_UNIQUE", BoolType()},
                     {"IS_NULL_FILTERED", BoolType()},
                     {"INDEX_STATE", StringType()},
                     {"SPANNER_IS_MANAGED", BoolType()},
                 });
  AddOwnedTable(indexes);
  return indexes;
}

void InformationSchemaCatalog::FillIndexesTable(
    zetasql::SimpleTable* indexes) {
  // Add table rows.
  std::vector<std::vector<zetasql::Value>> rows;
  for (const Table* table : default_schema_->tables()) {
    // Add normal indexes.
    for (const Index* index : table->indexes()) {
      rows.push_back({
          // table_catalog
          String(""),
          // table_schema
          String(""),
          // table_name
          String(table->Name()),
          // index_name
          String(index->Name()),
          // index_type
          String("INDEX"),
          // parent_table_name
          String(index->parent() ? index->parent()->Name() : ""),
          // is_unique
          Bool(index->is_unique()),
          // is_null_filtered
          Bool(index->is_null_filtered()),
          // index_state
          String("READ_WRITE"),
          // spanner_is_managed
          Bool(false),
      });
    }

    // Add the primary key index.
    rows.push_back({
        // table_catalog
        String(""),
        // table_schema
        String(""),
        // table_name
        String(table->Name()),
        // index_name
        String("PRIMARY_KEY"),
        // index_type
        String("PRIMARY_KEY"),
        // parent_table_name
        String(""),
        // is_unique
        Bool(true),
        // is_null_filtered
        Bool(false),
        // index_state
        NullString(),
        // spanner_is_managed
        Bool(false),
    });
  }

  // Add the primary key index for tables that live in INFORMATION_SCHEMA.
  for (const auto& table : this->tables()) {
    rows.push_back({
        // table_catalog
        String(""),
        // table_schema
        String(kInformationSchema),
        // table_name
        String(table->Name()),
        // index_name
        String("PRIMARY_KEY"),
        // index_type
        String("PRIMARY_KEY"),
        // parent_table_name
        String(""),
        // is_unique
        Bool(true),
        // is_null_filtered
        Bool(false),
        // index_state
        NullString(),
        // spanner_is_managed
        Bool(false),
    });
  }

  // Add table to catalog.
  indexes->SetContents(rows);
}

zetasql::SimpleTable* InformationSchemaCatalog::AddIndexColumnsTable() {
  // Setup table schema.
  auto index_columns = new zetasql::SimpleTable(
      "INDEX_COLUMNS", {
                           {"TABLE_CATALOG", StringType()},
                           {"TABLE_SCHEMA", StringType()},
                           {"TABLE_NAME", StringType()},
                           {"INDEX_NAME", StringType()},
                           {"INDEX_TYPE", StringType()},
                           {"COLUMN_NAME", StringType()},
                           {"ORDINAL_POSITION", Int64Type()},
                           {"COLUMN_ORDERING", StringType()},
                           {"IS_NULLABLE", StringType()},
                           {"SPANNER_TYPE", StringType()},
                       });

  // Add table to catalog.
  AddOwnedTable(index_columns);
  return index_columns;
}

void InformationSchemaCatalog::FillIndexColumnsTable(
    zetasql::SimpleTable* index_columns) {
  // Add table rows.
  std::vector<std::vector<zetasql::Value>> rows;
  for (const Table* table : default_schema_->tables()) {
    // Add normal indexes.
    for (const Index* index : table->indexes()) {
      int pos = 1;
      // Add key columns.
      for (const KeyColumn* key_column : index->key_columns()) {
        rows.push_back({
            // table_catalog
            String(""),
            // table_schema
            String(""),
            // table_name
            String(table->Name()),
            // index_name
            String(index->Name()),
            // index_type
            String("INDEX"),
            // column_name
            String(key_column->column()->Name()),
            // ordinal_position
            Int64(pos++),
            // column_ordering
            String(key_column->is_descending() ? "DESC" : "ASC"),
            // is_nullable
            String(key_column->column()->is_nullable() &&
                           !index->is_null_filtered()
                       ? "YES"
                       : "NO"),
            // spanner_type
            String(ColumnTypeToString(
                key_column->column()->GetType(),
                key_column->column()->declared_max_length())),
        });
      }

      // Add storing columns.
      for (const Column* column : index->stored_columns()) {
        rows.push_back({
            // table_catalog
            String(""),
            // table_schema
            String(""),
            // table_name
            String(table->Name()),
            // index_name
            String(index->Name()),
            // index_type
            String("INDEX"),
            // column_name
            String(column->Name()),
            // ordinal_position
            NullInt64(),
            // column_ordering
            NullString(),
            // is_nullable
            String(column->is_nullable() ? "YES" : "NO"),
            // spanner_type
            String(ColumnTypeToString(column->GetType(),
                                      column->declared_max_length())),
        });
      }
    }

    // Add the primary key columns.
    {
      int pos = 1;
      for (const KeyColumn* key_column : table->primary_key()) {
        rows.push_back({
            // table_catalog
            String(""),
            // table_schema
            String(""),
            // table_name
            String(table->Name()),
            // index_name
            String("PRIMARY_KEY"),
            // index_type
            String("PRIMARY_KEY"),
            // column_name
            String(key_column->column()->Name()),
            // ordinal_position
            Int64(pos++),
            // column_ordering
            String(key_column->is_descending() ? "DESC" : "ASC"),
            // is_nullable
            String(key_column->column()->is_nullable() ? "YES" : "NO"),
            // spanner_type
            String(ColumnTypeToString(
                key_column->column()->GetType(),
                key_column->column()->declared_max_length())),
        });
      }
    }
  }

  // Add the primary key columns.
  for (const auto& table : this->tables()) {
    int pos = 1;
    for (int i = 0; i < table->NumColumns(); ++i) {
      const zetasql::Column* column = table->GetColumn(i);
      // If there is no metadata entry, this is not a primary key column.
      auto m = TryFindMetadata(IndexColumnsMetadata(), table->Name(),
                               column->Name());
      if (m == IndexColumnsMetadata()->end()) {
        continue;
      }

      rows.push_back({
          // table_catalog
          String(""),
          // table_schema
          String(kInformationSchema),
          // table_name
          String(table->Name()),
          // index_name
          String("PRIMARY_KEY"),
          // index_type
          String("PRIMARY_KEY"),
          // column_name
          String(column->Name()),
          // ordinal_position
          Int64(pos++),
          // column_ordering
          String(m->column_ordering),
          // is_nullable
          String(m->is_nullable),
          // spanner_type
          String(m->spanner_type),
      });
    }
  }

  index_columns->SetContents(rows);
}

void InformationSchemaCatalog::AddColumnOptionsTable() {
  // Setup table schema.
  auto columns = new zetasql::SimpleTable("COLUMN_OPTIONS",
                                            {{"TABLE_CATALOG", StringType()},
                                             {"TABLE_SCHEMA", StringType()},
                                             {"TABLE_NAME", StringType()},
                                             {"COLUMN_NAME", StringType()},
                                             {"OPTION_NAME", StringType()},
                                             {"OPTION_TYPE", StringType()},
                                             {"OPTION_VALUE", StringType()}});

  // Add table rows.
  std::vector<std::vector<zetasql::Value>> rows;
  for (const Table* table : default_schema_->tables()) {
    for (const Column* column : table->columns()) {
      if (column->allows_commit_timestamp()) {
        rows.push_back({// table_catalog
                        String(""),
                        // table_schema
                        String(""),
                        // table_name
                        String(table->Name()),
                        // column_name
                        String(column->Name()),
                        // option_name
                        String("allow_commit_timestamp"), String("BOOL"),
                        // option_value
                        String("TRUE")});
      }
    }
  }

  // Add table to catalog.
  columns->SetContents(rows);
  AddOwnedTable(columns);
}

}  // namespace backend
}  // namespace emulator
}  // namespace spanner
}  // namespace google
